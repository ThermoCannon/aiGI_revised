Aim: To refactor the rules and installation codebase forked from the rUvnet Github repository. This will be done by reviewing, analyzing and consolidating rule docs, mode docs, system prompts, and install pipelines to redesign rUvnet into

Content tips:

1. Flavors of rUvnet exist, in which different modes with varying funcitonalities are defined.  Flavors include SPARC (found in ".roo"), unknown Cline flavor (found in ".clinerules"),

Design Principles:

- Flexibility - User should have multiple "entrypoint" modes from which to choose.  Each entrypoint has with it a pre-configured workflow that includes a customized set of modes.  When worked together under a defined workflow these modes execute tasks and interact with the user in unique ways.  In this way each entrypoint mode serves as a way for the user to select the right "fit" for the task as hand, or the project as a whole.  Each entrypoint acts as the orchestrator for its own customized workflow to meet the needs the user has for that particular session or development phase.  Entrypoint modes might include:
  - Data exploration: to determine data structures in flat files or databases; interact with remote databases through postman, etc; to create and run tools that perform checks, validation, visualization, reporting and so on, create and run tools that execute within data transformation pipelines.
  - Scripting solutions: to generate one-off scripting solutions, within existing project workspaces, relying on runtime troubleshooting and refactoring, focused on fast delivery and validation of functionality through analysis of provided or created outputs together with user-provided standards and guidelines.
  - Deliverable tools: to generate robust tool that can run workflows, bridge gaps in automated work, or perform other essential tasks needed by members of the larger team.  Expands on the "Scripting solutions" workflow to include small scale test-driven development, review-score-critic cycles, packaging of tools and their requirements or environments for sharing.
  - Project setup/maintenance: to a certain degree, all entrypoint orchestration modes must have as part of their workflow specifications a requirement to implement project documentation modes to maintain thorough and useful records of development phases and session progress.  The Project maintenance entrypoint workflow would specialize in reviewing project workspace organization according to guidelines and guardrails defined in the rules files and project documentation, and resoving any issues where project organization does not conform.  This would me more than a single mode, but would be an orchestration of modes responsible for documentation, organizing project filesystems, and so on. Includes Github repository maintenance.
  - Full stack development: the most comprehensive of the entrypoint workflows, includes robust test-driven development, has an early-project emphasis of heavy reliance on architecture and vision modes, deftly divides projects into phases with tasks and subtasks covering all aspects of product requirements, able to pick up from product requirements or roadmap documentation provided to it, with a very highly organized system of session documentation to track project progress, a thorough cycle of reviewer-scorer-critic analysis for prompting next-stage work to be done.  This entrypoint workflow is highly autonomous.
  - Codebase analysis: specializes in reviewing codebases large and small, conceptualizes based on documentation it finds, verifying against code it finds, it extrapolates functionality, interaction, and interdependence of code and other resources in a repository or project workspace.  Adeptly integrates the user's project aims with the current codebase state and recommends how to proceed using the optimal entrypoint workspace for further development.  Excels at creating comprehensive user documentation and technical documentation for existing code.
- Reproducibility - Every development experience, whether large or small, should always maintain high priority for working within strong guardrails for predictable and reproducible agent mode behavior.

* Multi-session integration - Since many development projects rely on iterative refinement and expansion over multiple development sessions, all aiGI workflows need to have strong "pick-up where we left off" session documentation.  Documentation and guidelines for particular development phases or for newly added tools and so on, need to be organized in a way that modes and easily refer to the correct docs for guidance, while also not over-writing or confusing project and session documentation already in the workspace.

Modes that may need to be added:

* Environment manager (makes sure that one or more virtual environments are managed and maintained for project use, keeping track of code requirements, checking for initialization of the proper venv, etc)
* Visionary (brainstorms with the user, creating planning documents, exploring options for anything from existing packages to public codebases, excels at producing mock-up designs, diagramming roadmaps, and expanding or refining the scope of projects and proof-of-concept work)
* Session Start/Stop (creates session summaries, chat history summaries, is run by the user at session end, but is always run by the entrypoint orchestrator at the beginning of a new session, as instructed by the user, is able to seamlessly follow a "pick up where we left off" paradigm to make multi-session work painless.
* Data scientist (specializes in Python Pandas, R magics, Jupyter notebooks, DASH/plotly, Seaborn, Matplotlib, ggplot, and is knowledgable about the application of advanced statistical and machine learning methods)
* Brute code (coding mode designed to be used for simpler project aims, primarily develops by creating code and then running to detect errors and warnings and then refactors and repeats, meant as a fast-and-furious approach in contrast to the longer more robust test-driven development mode paradigm)
  Project setup (a mode integral to the Project maintenance entrypoint that creates everything needed for a project based on project needs and guidelines.  Might be integrated with the "Environment manager" mode)
* Other modes might include pseudocoder, image creator (provided a personal API token for vision models), webpage browser/scraper, security review, different flavors of documentation writer modes to serve the purposes of different stages in workflows (see for example Documentation Writer and Specification Writer),

Modes from the rUvNet whose functionality can probably be consolidated into other modes: tutorial, prompt-generator, MCP integrator, SPARC orchestrator, aiGI orchestrator, Supabase, system integrator, optimizer, dev ops, deployment monitor

Installation should overwrite (through the use of "slugs") the default Roo Code modes: Architect, Auto-coder, Ask, Debugger, Orchestrator.  They should get replaced with the most similar custom mode from my revised rUvnet/aiGI system. Project-level mode overrides can be implemented by using the same "slug" as a default mode in the YAML configuration file, like this:
customModes:

- slug: code # Matches the default 'code' mode slug
  name: ðŸ’» Code (Project-Specific) # Custom display name
  roleDefinition: You are a software engineer with project-specific constraints for this project.
  whenToUse: This project-specific code mode is for Python tasks within this project.
  customInstructions: Adhere to PEP8 and use type hints.
  groups:
  - read
  - - edit
    - fileRegex: \.py$
      description: Python files only
  - command
    The slugs for the default modes are "architect", "ask", "code", "debug", and "orchestrator"
    Make sure to review AT LEAST all of the modes defined in rules and readme files in the directories and subfolders: aiGI, clinerules-bank/orchestration, plans/phases, templates/minimal-roo/.roo, .clinerules, .roo, roo_mode_defaults

The Roo Code system prompt can be found in the repo at "roo_mode_defaults/system_prompt.md" and is the document that defines the default behavior of the Roo Modes.  Review this doc and look for a system prompt doc that belongs to the default rUv-net modes.  The install and set up of the revised aiGI system should include the implementation and customization of a new system prompt.  It should be dynamically updated at the project level with information about file folder structure, the current workspace directory, and should be edited to provide more autonomy in tool use, task handoff, and other operations to prevent mode workflows from indefinite stalls.

Mode Rules and Instruction improvements: orchestrators should be able to write their own log files, all modes should write a log file, applying diff should always first include re-reading the file to obtain the current version before creating and applying diffs, all modes should have a failsafe task-end action of passing back to the entrypoint orchestration mode of the current workflow, the orchestration mode should consistently review the most recent entries of the logs from the modes that have run during the session and include those in the task history/context and make next-step decisions based off of the last work completed.  Debugger mode is notoriously ineffective and needs improved instructions to make it work more systematically, performing differential diagnostics to isolate causes of code failure, relying heavily on runtime execution and review of error followed by refactoring in a cycle.  The memory manager mode needs to include within it the necessary knowledge and instructions to guid the user through setting up the local database to be used as the memory store.  Modes should also have the proper instructions to retrieve codebase data from Roo Code's built-in codebase indexing.  A user could conceivably run a local embedder model through Ollama without needing to point to a paid API (here I'm speaking about Roo Code's code vectorization).

MCP servers should be specifically enabled for use by specific modes.  They would include Perplexity MCP, Context7 MCP, Serena MCP, Github MCP and Markitdown MCP and would ideally be permitted for use by modes designed for brainstorming and planning, coding and refactoring, and project organization and maintenance, respectively.

I want this to be based on the rUvnet system, but to simplify by consolidation of all "flavors".  Instead of "flavors" like mini or aiGI we will have these difference entrypoint modes that orchestrate workkflows with distinct patterns and capabilities.  Installation should run similar to how rUv-net SPARC aiGI currently installs, but will set up the pre-configured MCP servers int he workspace, and will update rules and other .md definition files for functionality in the new project space.  Pay close attention to the various scripts that are part of the installer and installation manager process.  This can be simplified into a single installer with very few options.

I need a comprehensive document, as long as it needs to be, that details all of the changes that should be made to the current state of the code and files in the repository to align with my new aims.  This doc needs to be able to be followed by another AI coding system (Roo Code agent modes using Gemini 2.5 Pro) which will implement and push the changes.  Review the entire codebase of the AIGI_REVISED workspace, including documentation and other items. Then provide a comprehensive report on your analysis, including a complete roadmap of tasks to complete in order to modify the code to reflect the changes outlined above.
